/**
* Code written by Erick de Almeida Oliveira Riso and Heitor da Silva Santos,26 de novembro de 2018
* SAT Solver
*
* Partial requirement for the Computing Introdution subject of the Computer Science course
* on Universidade Federal de Pernambuco.
*
* Based on Fernando Castor' sat solver model. 
*/
exports.solve = function(fileName) {
  let formula = readFormula(fileName)
  let result = doSolve(formula.clauses, formula.variables)
  return result 
}
function doSolve(clauses, assignment) {
  /** It starts with all clauses being true, because if you prove that just one is false, you
   * can say that the assignment is invalid. In the same way, the clause in itself starts being 
   * true, because we are talking about "or", then if you find a variable true, the whole
   * expression is true. And than you pass to the new clause. 
  */
  let isSat = false
  let allClauses = true
  let clause = false
  let firstAssignment = new Array(assignment.length);
  //the first assignment will always be a lot of zeros
  firstAssignment = firstAssignment.fill(0);
  let result = {'isSat':null,'satisfyingAssignment':null}
  for(let i=0;i<clauses.length && allClauses;i++){
    for(let j=0;j<clauses[i].length && !clause;j++){
      let value = clauses[i][j];
      let valueAbs = Math.abs(value)
      /**the condition to a variable be true is that it's position in the  assignment must be 
       * true (or 1) if it's being confirmed or false(or 0) if it's being denied. The position is
       * 'value-1' because the assignment starts, obviously, in the zero, but the variables starts
       * in the one
       */
      if((value>0 && assignment[value-1]==1)||(value<0 && assignment[valueAbs-1]==0)){
        clause = true
      }
    }
    if(!clause){
      allClauses= false
    }
  }
  if(allClauses){
    result.isSat = true
    result.satisfyingAssignment= assignment
  }
  else{
    /** If all clauses are true, then you have your answer. But if the current assignment is
     * invalid and the next assignment isn't the first, you do all this function again, but with 
     * a new assignment; if the next assginment is equal to the first, it means that you've 
     * tried all the possibilities; then the clauses aren't satisfiable.
   */ 
    nextAssignment = nextAssignment(assignment)
    if(firstAssignment!=nextAssignment){
      return doSolve(clauses,nextAssignment)
    }
    else{
      result.isSat=false
    }
  }
  return result
}
function nextAssignment(currentAssignment) {
  let i=currentAssignment.length-1
  let flag = false
  //this first while will find the first zero from the right to the left and replace it for a one
  do{
    if(currentAssignment[i]==0){
      currentAssignment[i]=1
      flag = true     
      i++
    }
    else{
      i--
    }
  }while(i>=0 && !flag)
  //this second while will replace every value from the new "one" to the right for a new "zero"
  while(i<currentAssignment.length){
    currentAssignment[i]=0
    i++
  } 
  return currentAssignment
}

function readFormula(fileName) {
  const fs = require('fs');
  //the regex below will split the text between line breaks
  let text = fs.readFileSync(fileName).split(/[\r\n]+/) 
  let clauses = readClauses(text)
  let variables = readVariables(clauses)
  let specOk = checkProblemSpecification(text, clauses, variables)
  let result = { 'clauses': [], 'variables': [] }
  if (specOk) {
    result.clauses = clauses
    result.variables = variables
  }
  return result
}
function readClauses(text) {
  let clause = []//each position is a variable of a clause
  let clauses = []//each position is a clause
  for(let i=0;i<text.length;i++){
    let lineArray = text[i].split(' ')//it splits the clause on the spaces
    if(lineArray[0]!='p'&&lineArray[0]!='c'){//it will only be a clause if it doesn't start with a 'c' or a 'p'
      for(let j=0;j<lineArray.length;j++){
        if(lineArray[i]!='0'){
          clause.push(text[i][j])//it adds a variable to a clause if it's not zero
        }
        else{
          clauses.push(clause)//if it's a zero, it pushs a clause to an array of clauses
          clause = []//and then it clears a zero 
        }
      }
    }
  } 
  return clauses
}
function readVariables(clauses){
  /** It reads all variables present in the clauses and replaces the '-' for a '', in order to not
   * to count twice a variable wich's being denied. Then if the variable isn't included on the 
   * array, it will add to an array, and push a new zero to a boolean array of variables, wich,
   * in the end, is what the function will return
   */
  let contVariables = []
  let variables = []
  for(let i=0;i<clauses.length;i++){
    for(let j=0;j<clauses[i].length;j++){
      clauses[i][j] = clauses[i][j].replace('-','');
      if(!contVariables.includes(clauses[i][j])){
        contVariables.push(clauses[i][j]);
        variables.push(false);
      }
    }  
  }
  return variables;
}
function checkProblemSpecification(text, clauses, variables){
  let i =0
  let flag = false
  /** 
   * it searchs for a line that starts with a 'p', if it finds it, then splits the line between
   * spaces and put a true value on flag
   */ 
  while(text[i].charAt(0)!='p'&& i<text.length) {
    if(text[i].charAt(0)=='p'){
      let spec= text[i].split(' ')
      flag=true
    }
    i++
  }
  //if flag is true, it means that does exist a a specification line that needs to be checked
  if(flag){
    //it compares the specification line with the number of variables and clauses
    if(spec[3]==variables.length && spec[4]==clauses.length){
      return true
    } 
    else{
      return false
    }
  }  
  //if it's false, there's nothing to be checked
  else{
    return flag
  }
}