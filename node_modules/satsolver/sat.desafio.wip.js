/**
* Erick de Almeida Oliveira Riso, 18 de novembro de 2018
* SAT Solver (solucionador do problema de satisfatibilidade booleana)
* 
* Requisito parcial para a disciplina de Introdução a Programação do
* curso de Ciência da Computação na Universidade Federal de Pernambuco.
* 
* Baseado no modelo de Fernando Castor.
* DESAFIO
* 
*/
exports.solve = function (fileName) {
  let formula = readFormula(fileName)
  let result = doSolve(formula.clauses, formula.variables)
  return result // Dois campos: isSat e satisfyingAssignment
}

// Recebe a tentativa atual e devolve a próxima
function nextAssignment(assignment) {
  let doneIncrement = false
  let arrayIndex = assignment.length - 1
  
  while (!doneIncrement && arrayIndex >= 0) {
    if (assignment[arrayIndex] == false) {
      assignment[arrayIndex] = true
      doneIncrement = true
    }
    if (!doneIncrement) {
      arrayIndex--
    }
  }
  
  arrayIndex++
  while (arrayIndex < assignment.length) {
    assignment[arrayIndex] = false
    arrayIndex++
  }
  
  return assignment
}

function doSolve(clauses, assignment) {
  let isSat = false
  let maximumAssignments = Math.pow(2, assignment.length)
  // Funciona como esperado com até 52 variáveis
  console.log("Serão realizadas, no máximo, " + maximumAssignments + " verificações." )
  let currentAssigment = 1
  
  while ((!isSat) && !(currentAssigment == maximumAssignments)) {
    // Verifica se a tentativa atual satisfaz a fórmula
    
    let allClausesTrue = true
    
    console.log("Analisando a tentativa " + currentAssigment + " de " + maximumAssignments + "...")
    
    for (let clause = 0; clause < clauses.length && allClausesTrue; clause++) {
      let thisClauseTrue = false
      for (let literal = 0; literal < clauses[clause].length && !thisClauseTrue; literal++) {
        let thisLiteralTrue = false
        let literalValue = assignment[Math.abs(clauses[clause][literal]) - 1]
        if (clauses[clause][literal].startsWith("-")) {
          thisLiteralTrue = !literalValue
        } else {
          thisLiteralTrue = literalValue
        }
        if (thisLiteralTrue) {
          thisClauseTrue = true;
          console.log("Cláusula " + (clause + 1) + " verdadeira.")
        }
      }
      if (!thisClauseTrue) {
        allClausesTrue = false;
        console.log("A cláusula " + (clause + 1) + " da tentativa " + currentAssigment + " é falsa.")
      }
    }
    
    if (allClausesTrue) {
      isSat = true
      // Se todas as cláusulas são verdadeiras, define isSat como verdadeiro
      console.log("Todas as cláusulas são verdadeiras. Portanto, a fórmula é satisfatível.")
    } else {
      // Se não, requisita a próxima tentativa e repete
      assignment = nextAssignment(assignment)
      currentAssigment++
    }
    
  }
  let result = {
    'isSat': isSat,
    satisfyingAssignment: null
  }
  if (isSat) {
    result.satisfyingAssignment = assignment
  }
  return result
}

function readFormula(fileName) {
  // Usando o módulo 'fs' para ler o arquivo

  const fs = require('fs')
  let text = removeComments(fs.readFileSync(fileName, 'utf8').split(/[\r\n]+/))
  // Uma array contendo as linhas do texto extraído do arquivo
  // Usando regex para funcionar com retornos de linha CR, LF e CRLF
  let clauses = readClauses(text)
  console.log("Cláusulas lidas: " + clauses)
  let variables = readVariables(clauses)
  console.log(variables.length + " variáveis lidas")
  
  // Na linha seguinte, o texto é passado como argumento para que
  // a função possa extrair a especificação do problema
  let specOk = checkProblemSpecification(text, clauses, variables)
  
  console.log("Resultado do teste de especificação: " + specOk)
  
  let result = {
    'clauses': [],
    'variables': []
  }
  if (specOk) {
    result.clauses = clauses
    result.variables = variables
  }
  return result
}

function readClauses(text) {
  let clauses = []
  let clause = []
  for (let line = 0; line < text.length; line++) {
    let lineContent = text[line]
    if (!(lineContent.startsWith('p cnf'))) {
      let splittedLine = lineContent.split(' ')
      for (let unit = 0; unit < splittedLine.length; unit++) {
        if (splittedLine[unit] != '0') {
          if (isStringIntNumber(splittedLine[unit])){ 
            clause.push(splittedLine[unit])
          }
        } else {
          clauses.push(clause)
          clause = []
        }
      }
    }
  }
  return clauses
}

function readVariables(clauses) {
  let variableList = []
  
  for (let clause = 0; clause < clauses.length; clause++) {
    for (let literal = 0; literal < clauses[clause].length; literal++) {
      let variable = clauses[clause][literal].replace('-','')
      if (!(variableList.includes(variable))) {
        variableList.push(variable)
      }
    }
  }
  let variables = new Array(variableList.length).fill(false)
  return variables
}

function checkProblemSpecification(text, clauses, variables) {
  problemLine = text[0].split(' ')

  // Verifica se a linha de especificação existe
  let isCnf = (problemLine[0] == 'p') && (problemLine[1] == 'cnf') && (isStringNatNumber(problemLine[2])) && (isStringNatNumber(problemLine[3]))
  let sameClausesAmount
  let sameVariablesAmount
  
  // Verifica se a quantidade de cláusulas e variáveis estão corretas
  if (isCnf) {
    let declaredVariablesAmount = problemLine[2]
    let declaredClausesAmount = problemLine[3]
    sameClausesAmount = (declaredClausesAmount == clauses.length)
    sameVariablesAmount = (declaredVariablesAmount == variables.length)
  }
  
  return (isCnf && sameClausesAmount && sameVariablesAmount)
}

// Outras funções

function removeComments(text) {
  let cleanText = []
  for (let line = 0; line < text.length; line++) {
    let firstChar = text[line].charAt(0)
    if (!(firstChar == 'c')) {
      cleanText.push(text[line])
    }
  }
  return cleanText
}

function isStringNatNumber(n) {
  return n.match(/^\d+$/)
}

function isStringIntNumber(n) {
  return n.match(/^-{0,1}\d+$/)
}